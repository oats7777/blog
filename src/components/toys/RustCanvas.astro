---
import styles from '@/styles/toys/RustCanvas.module.css';
---

<div class={styles.container}>
  <div class={styles.toolbar}>
    <div class={styles.toolGroup}>
      <label>도구</label>
      <div class={styles.tools}>
        <button id="selectBtn" class={styles.toolBtn} data-active="false" title="선택 (V)">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z" />
            <path d="M13 13l6 6" />
          </svg>
        </button>
        <button id="penBtn" class={styles.toolBtn} data-active="true" title="펜">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M12 19l7-7 3 3-7 7-3-3z" />
            <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z" />
            <path d="M2 2l7.586 7.586" />
          </svg>
        </button>
        <button id="eraserBtn" class={styles.toolBtn} data-active="false" title="지우개">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M20 20H7L3 16c-.8-.8-.8-2 0-2.8L13.4 3c.8-.8 2-.8 2.8 0L21 7.8c.8.8.8 2 0 2.8L10 20" />
          </svg>
        </button>
      </div>
    </div>

    <div class={styles.toolGroup}>
      <label>편집</label>
      <div class={styles.tools}>
        <button id="undoBtn" class={styles.actionBtn} title="실행취소 (Ctrl+Z)">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="1 4 1 10 7 10" />
            <path d="M3.51 15a9 9 0 102.13-9.36L1 10" />
          </svg>
          <span>취소</span>
        </button>
        <button id="redoBtn" class={styles.actionBtn} title="다시실행 (Ctrl+Shift+Z)">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="23 4 23 10 17 10" />
            <path d="M20.49 15a9 9 0 11-2.13-9.36L23 10" />
          </svg>
          <span>다시</span>
        </button>
        <button id="copyBtn" class={styles.actionBtn} title="복사 (Ctrl+C)">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2" />
            <path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1" />
          </svg>
          <span>복사</span>
        </button>
        <button id="pasteBtn" class={styles.actionBtn} title="붙여넣기 (Ctrl+V)">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M16 4h2a2 2 0 012 2v14a2 2 0 01-2 2H6a2 2 0 01-2-2V6a2 2 0 012-2h2" />
            <rect x="8" y="2" width="8" height="4" rx="1" ry="1" />
          </svg>
          <span>붙여넣기</span>
        </button>
        <button id="deleteBtn" class={styles.actionBtn} title="삭제 (Delete)">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="3 6 5 6 21 6" />
            <path d="M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2" />
          </svg>
          <span>삭제</span>
        </button>
        <button id="selectAllBtn" class={styles.actionBtn} title="전체선택 (Ctrl+A)">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="3" y="3" width="18" height="18" rx="2" ry="2" stroke-dasharray="4 2" />
            <path d="M9 12l2 2 4-4" />
          </svg>
          <span>전체선택</span>
        </button>
      </div>
    </div>

    <div class={styles.toolGroup}>
      <label>색상</label>
      <div class={styles.colors}>
        <input type="color" id="colorPicker" value="#000000" />
        <button class={styles.colorBtn} data-color="#000000" data-active="true" style="background:#000000"></button>
        <button class={styles.colorBtn} data-color="#ef4444" data-active="false" style="background:#ef4444"></button>
        <button class={styles.colorBtn} data-color="#f97316" data-active="false" style="background:#f97316"></button>
        <button class={styles.colorBtn} data-color="#eab308" data-active="false" style="background:#eab308"></button>
        <button class={styles.colorBtn} data-color="#22c55e" data-active="false" style="background:#22c55e"></button>
        <button class={styles.colorBtn} data-color="#3b82f6" data-active="false" style="background:#3b82f6"></button>
        <button class={styles.colorBtn} data-color="#8b5cf6" data-active="false" style="background:#8b5cf6"></button>
      </div>
    </div>

    <div class={styles.toolGroup}>
      <label>굵기: <span id="sizeValue">5</span>px</label>
      <input type="range" id="sizeSlider" min="1" max="50" value="5" />
    </div>

    <div class={styles.toolGroup}>
      <button id="clearBtn" class={styles.clearBtn}>전체 지우기</button>
    </div>
  </div>

  <div class={styles.canvasContainer}>
    <canvas id="rust-canvas"></canvas>
  </div>
</div>

<script>
  import init, { Canvas } from '@/lib/wasm/rust-canvas/rust_canvas.js';

  interface Position {
    x: number;
    y: number;
  }

  const LOGICAL_WIDTH = 800;
  const LOGICAL_HEIGHT = 500;

  let currentTool: 'pen' | 'eraser' | 'select' = 'pen';

  // getBoundingClientRect 캐시 (드래그 중 레이아웃 재계산 방지)
  let cachedRect: DOMRect | null = null;

  function cacheRect(canvasEl: HTMLCanvasElement): void {
    cachedRect = canvasEl.getBoundingClientRect();
  }

  function getPosition(e: MouseEvent | TouchEvent, canvasEl: HTMLCanvasElement): Position {
    const rect = cachedRect || canvasEl.getBoundingClientRect();
    const scaleX = LOGICAL_WIDTH / rect.width;
    const scaleY = LOGICAL_HEIGHT / rect.height;

    if ('touches' in e && e.touches.length > 0) {
      return {
        x: (e.touches[0].clientX - rect.left) * scaleX,
        y: (e.touches[0].clientY - rect.top) * scaleY,
      };
    }

    const mouseEvent = e as MouseEvent;
    return {
      x: (mouseEvent.clientX - rect.left) * scaleX,
      y: (mouseEvent.clientY - rect.top) * scaleY,
    };
  }

  function setActiveState(element: Element, isActive: boolean): void {
    element.setAttribute('data-active', String(isActive));
  }

  function setupCanvasSize(canvasEl: HTMLCanvasElement): number {
    const dpr = window.devicePixelRatio || 1;

    canvasEl.width = LOGICAL_WIDTH * dpr;
    canvasEl.height = LOGICAL_HEIGHT * dpr;
    canvasEl.style.width = `${LOGICAL_WIDTH}px`;
    canvasEl.style.height = `${LOGICAL_HEIGHT}px`;

    return dpr;
  }

  function setupDrawingEvents(canvasEl: HTMLCanvasElement, canvas: Canvas): void {
    // Mouse events
    canvasEl.addEventListener('mousedown', (e) => {
      cacheRect(canvasEl);
      const pos = getPosition(e, canvasEl);

      if (currentTool === 'select') {
        // 이미 선택된 스트로크 위 클릭 → 이동
        if (canvas.has_selection() && canvas.is_over_selected(pos.x, pos.y)) {
          canvas.start_move(pos.x, pos.y);
        } else {
          // 스트로크 위 클릭 → 개별 선택
          const hit = canvas.try_select_at(pos.x, pos.y, e.shiftKey);
          if (hit && canvas.is_over_selected(pos.x, pos.y)) {
            canvas.start_move(pos.x, pos.y);
          } else if (!hit) {
            // 빈 영역 클릭 → 러버밴드 시작
            canvas.start_rubber_band(pos.x, pos.y);
          }
          canvas.render();
        }
      } else {
        canvas.start_drawing(pos.x, pos.y);
      }
    });

    canvasEl.addEventListener('mousemove', (e) => {
      const pos = getPosition(e, canvasEl);

      if (currentTool === 'select') {
        if (canvas.get_is_rubber_band()) {
          canvas.update_rubber_band(pos.x, pos.y);
          canvasEl.style.cursor = 'crosshair';
        } else if (canvas.get_is_moving()) {
          canvas.move_selected(pos.x, pos.y);
        } else {
          // 이동/러버밴드 아닌 hover — 커서만 변경, render 스킵
          if (canvas.has_selection() && canvas.is_over_selected(pos.x, pos.y)) {
            canvasEl.style.cursor = 'move';
          } else {
            canvasEl.style.cursor = 'default';
          }
        }
      } else {
        canvas.update_cursor(pos.x, pos.y);
        if (canvas.get_is_drawing()) {
          canvas.draw(pos.x, pos.y);
        } else {
          canvas.render();
        }
      }
    });

    canvasEl.addEventListener('mouseup', (e) => {
      if (currentTool === 'select') {
        if (canvas.get_is_rubber_band()) {
          canvas.finish_rubber_band(e.shiftKey);
        }
        canvas.stop_move();
      } else {
        canvas.stop_drawing();
      }
      cachedRect = null;
    });

    canvasEl.addEventListener('mouseleave', (e) => {
      if (currentTool === 'select') {
        if (canvas.get_is_rubber_band()) {
          canvas.finish_rubber_band(e.shiftKey);
        }
        canvas.stop_move();
      } else {
        canvas.stop_drawing();
      }
      canvas.hide_cursor();
      canvas.render();
      cachedRect = null;
    });

    // Touch events
    canvasEl.addEventListener(
      'touchstart',
      (e) => {
        e.preventDefault();
        cacheRect(canvasEl);
        const pos = getPosition(e, canvasEl);

        if (currentTool === 'select') {
          if (canvas.has_selection() && canvas.is_over_selected(pos.x, pos.y)) {
            canvas.start_move(pos.x, pos.y);
          } else {
            const hit = canvas.try_select_at(pos.x, pos.y, false);
            if (hit && canvas.is_over_selected(pos.x, pos.y)) {
              canvas.start_move(pos.x, pos.y);
            } else if (!hit) {
              canvas.start_rubber_band(pos.x, pos.y);
            }
            canvas.render();
          }
        } else {
          canvas.start_drawing(pos.x, pos.y);
        }
      },
      { passive: false }
    );

    canvasEl.addEventListener(
      'touchmove',
      (e) => {
        e.preventDefault();
        const pos = getPosition(e, canvasEl);

        if (currentTool === 'select') {
          if (canvas.get_is_rubber_band()) {
            canvas.update_rubber_band(pos.x, pos.y);
          } else if (canvas.get_is_moving()) {
            canvas.move_selected(pos.x, pos.y);
          }
        } else {
          canvas.draw(pos.x, pos.y);
        }
      },
      { passive: false }
    );

    canvasEl.addEventListener('touchend', () => {
      if (currentTool === 'select') {
        if (canvas.get_is_rubber_band()) {
          canvas.finish_rubber_band(false);
        }
        canvas.stop_move();
      } else {
        canvas.stop_drawing();
      }
      cachedRect = null;
    });
  }

  function setupToolButtons(
    canvas: Canvas,
    penBtn: Element,
    eraserBtn: Element,
    selectBtn: Element,
    canvasEl: HTMLCanvasElement
  ): void {
    const allToolBtns = [selectBtn, penBtn, eraserBtn];

    function activateTool(activeBtn: Element, tool: 'pen' | 'eraser' | 'select') {
      allToolBtns.forEach((btn) => setActiveState(btn, btn === activeBtn));
      currentTool = tool;

      canvas.set_eraser(tool === 'eraser');
      canvas.set_select_mode(tool === 'select');

      if (tool === 'select') {
        canvasEl.style.cursor = 'default';
      } else {
        canvasEl.style.cursor = 'none';
        canvas.deselect_all();
      }

      canvas.render();
    }

    selectBtn.addEventListener('click', () => activateTool(selectBtn, 'select'));
    penBtn.addEventListener('click', () => activateTool(penBtn, 'pen'));
    eraserBtn.addEventListener('click', () => activateTool(eraserBtn, 'eraser'));
  }

  function setupActionButtons(canvas: Canvas): void {
    const undoBtn = document.getElementById('undoBtn');
    const redoBtn = document.getElementById('redoBtn');
    const copyBtn = document.getElementById('copyBtn');
    const pasteBtn = document.getElementById('pasteBtn');
    const deleteBtn = document.getElementById('deleteBtn');
    const selectAllBtn = document.getElementById('selectAllBtn');

    undoBtn?.addEventListener('click', () => canvas.undo());
    redoBtn?.addEventListener('click', () => canvas.redo());

    copyBtn?.addEventListener('click', () => {
      if (canvas.has_selection()) {
        canvas.copy_selected();
      }
    });

    pasteBtn?.addEventListener('click', () => {
      canvas.paste();
    });

    deleteBtn?.addEventListener('click', () => {
      if (canvas.has_selection()) {
        canvas.delete_selected();
      }
    });

    selectAllBtn?.addEventListener('click', () => {
      canvas.select_all();
      canvas.render();
    });
  }

  function setupColorControls(
    canvas: Canvas,
    colorPicker: HTMLInputElement,
    colorBtns: NodeListOf<Element>,
    penBtn: Element,
    eraserBtn: Element,
    selectBtn: Element,
    canvasEl: HTMLCanvasElement
  ): void {
    const allToolBtns = [selectBtn, penBtn, eraserBtn];

    colorPicker.addEventListener('input', (e) => {
      const target = e.target as HTMLInputElement;
      canvas.set_color(target.value);
      currentTool = 'pen';
      allToolBtns.forEach((btn) => setActiveState(btn, btn === penBtn));
      canvasEl.style.cursor = 'none';
      canvas.deselect_all();
      colorBtns.forEach((btn) => setActiveState(btn, false));
      canvas.render();
    });

    colorBtns.forEach((btn) => {
      btn.addEventListener('click', () => {
        const color = (btn as HTMLElement).dataset.color;
        if (!color) return;

        canvas.set_color(color);
        colorPicker.value = color;
        currentTool = 'pen';
        allToolBtns.forEach((b) => setActiveState(b, b === penBtn));
        canvasEl.style.cursor = 'none';
        canvas.deselect_all();
        colorBtns.forEach((b) => setActiveState(b, false));
        setActiveState(btn, true);
        canvas.render();
      });
    });
  }

  function setupSizeSlider(canvas: Canvas, sizeSlider: HTMLInputElement, sizeValue: Element): void {
    sizeSlider.addEventListener('input', (e) => {
      const target = e.target as HTMLInputElement;
      const size = parseInt(target.value, 10);
      canvas.set_line_width(size);
      sizeValue.textContent = String(size);
      canvas.render();
    });
  }

  function setupKeyboardShortcuts(canvas: Canvas): void {
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Delete' || e.key === 'Backspace') {
        if (canvas.has_selection()) {
          e.preventDefault();
          canvas.delete_selected();
        }
      }

      if (e.ctrlKey || e.metaKey) {
        if (e.key === 'z' && !e.shiftKey) {
          e.preventDefault();
          canvas.undo();
        }
        if (e.key === 'z' && e.shiftKey) {
          e.preventDefault();
          canvas.redo();
        }
        if (e.key === 'y') {
          e.preventDefault();
          canvas.redo();
        }
        if (e.key === 'c') {
          if (canvas.has_selection()) {
            e.preventDefault();
            canvas.copy_selected();
          }
        }
        if (e.key === 'v') {
          e.preventDefault();
          canvas.paste();
        }
        if (e.key === 'a') {
          if (currentTool === 'select') {
            e.preventDefault();
            canvas.select_all();
            canvas.render();
          }
        }
      }

      if (e.key === 'Escape') {
        canvas.deselect_all();
        canvas.render();
      }
    });
  }

  async function initRustCanvas(): Promise<void> {
    await init();

    const canvasEl = document.getElementById('rust-canvas') as HTMLCanvasElement | null;
    if (!canvasEl) {
      console.error('Canvas element not found');
      return;
    }

    const dpr = setupCanvasSize(canvasEl);
    const canvas = new Canvas('rust-canvas', dpr);
    canvas.clear();

    const selectBtn = document.getElementById('selectBtn');
    const penBtn = document.getElementById('penBtn');
    const eraserBtn = document.getElementById('eraserBtn');
    const colorPicker = document.getElementById('colorPicker') as HTMLInputElement | null;
    const colorBtns = document.querySelectorAll('[data-color]');
    const sizeSlider = document.getElementById('sizeSlider') as HTMLInputElement | null;
    const sizeValue = document.getElementById('sizeValue');
    const clearBtn = document.getElementById('clearBtn');

    if (!selectBtn || !penBtn || !eraserBtn || !colorPicker || !sizeSlider || !sizeValue || !clearBtn) {
      console.error('Required elements not found');
      return;
    }

    canvasEl.style.cursor = 'none';

    setupDrawingEvents(canvasEl, canvas);
    setupToolButtons(canvas, penBtn, eraserBtn, selectBtn, canvasEl);
    setupActionButtons(canvas);
    setupColorControls(canvas, colorPicker, colorBtns, penBtn, eraserBtn, selectBtn, canvasEl);
    setupSizeSlider(canvas, sizeSlider, sizeValue);
    setupKeyboardShortcuts(canvas);

    clearBtn.addEventListener('click', () => canvas.clear());
  }

  initRustCanvas();
</script>
