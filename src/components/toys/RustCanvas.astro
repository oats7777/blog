---
import styles from '@/styles/toys/RustCanvas.module.css';
---

<div class={styles.container}>
  <div class={styles.toolbar}>
    <div class={styles.toolGroup}>
      <label>도구</label>
      <div class={styles.tools}>
        <button id="selectBtn" class={styles.toolBtn} data-active="false" title="선택 (V)">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z" />
            <path d="M13 13l6 6" />
          </svg>
        </button>
        <button id="penBtn" class={styles.toolBtn} data-active="true" title="펜">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M12 19l7-7 3 3-7 7-3-3z" />
            <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z" />
            <path d="M2 2l7.586 7.586" />
          </svg>
        </button>
        <button id="eraserBtn" class={styles.toolBtn} data-active="false" title="지우개">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M20 20H7L3 16c-.8-.8-.8-2 0-2.8L13.4 3c.8-.8 2-.8 2.8 0L21 7.8c.8.8.8 2 0 2.8L10 20" />
          </svg>
        </button>
        <button id="lineBtn" class={styles.toolBtn} data-active="false" title="직선 (L)">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="5" y1="19" x2="19" y2="5" />
          </svg>
        </button>
        <button id="rectBtn" class={styles.toolBtn} data-active="false" title="사각형 (R)">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="4" y="4" width="16" height="16" rx="1" />
          </svg>
        </button>
        <button id="circleBtn" class={styles.toolBtn} data-active="false" title="원 (O)">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="9" />
          </svg>
        </button>
      </div>
    </div>

    <div class={styles.toolGroup}>
      <label>편집</label>
      <div class={styles.tools}>
        <button id="undoBtn" class={styles.actionBtn} title="실행취소 (Ctrl+Z)">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="1 4 1 10 7 10" />
            <path d="M3.51 15a9 9 0 102.13-9.36L1 10" />
          </svg>
          <span>취소</span>
        </button>
        <button id="redoBtn" class={styles.actionBtn} title="다시실행 (Ctrl+Shift+Z)">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="23 4 23 10 17 10" />
            <path d="M20.49 15a9 9 0 11-2.13-9.36L23 10" />
          </svg>
          <span>다시</span>
        </button>
        <button id="copyBtn" class={styles.actionBtn} title="복사 (Ctrl+C)">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2" />
            <path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1" />
          </svg>
          <span>복사</span>
        </button>
        <button id="pasteBtn" class={styles.actionBtn} title="붙여넣기 (Ctrl+V)">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M16 4h2a2 2 0 012 2v14a2 2 0 01-2 2H6a2 2 0 01-2-2V6a2 2 0 012-2h2" />
            <rect x="8" y="2" width="8" height="4" rx="1" ry="1" />
          </svg>
          <span>붙여넣기</span>
        </button>
        <button id="deleteBtn" class={styles.actionBtn} title="삭제 (Delete)">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="3 6 5 6 21 6" />
            <path d="M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2" />
          </svg>
          <span>삭제</span>
        </button>
        <button id="selectAllBtn" class={styles.actionBtn} title="전체선택 (Ctrl+A)">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="3" y="3" width="18" height="18" rx="2" ry="2" stroke-dasharray="4 2" />
            <path d="M9 12l2 2 4-4" />
          </svg>
          <span>전체선택</span>
        </button>
      </div>
    </div>

    <div class={styles.toolGroup}>
      <label>색상</label>
      <div class={styles.colors}>
        <input type="color" id="colorPicker" value="#000000" />
        <button class={styles.colorBtn} data-color="#000000" data-active="true" style="background:#000000"></button>
        <button class={styles.colorBtn} data-color="#ef4444" data-active="false" style="background:#ef4444"></button>
        <button class={styles.colorBtn} data-color="#f97316" data-active="false" style="background:#f97316"></button>
        <button class={styles.colorBtn} data-color="#eab308" data-active="false" style="background:#eab308"></button>
        <button class={styles.colorBtn} data-color="#22c55e" data-active="false" style="background:#22c55e"></button>
        <button class={styles.colorBtn} data-color="#3b82f6" data-active="false" style="background:#3b82f6"></button>
        <button class={styles.colorBtn} data-color="#8b5cf6" data-active="false" style="background:#8b5cf6"></button>
      </div>
    </div>

    <div class={styles.toolGroup}>
      <label>굵기: <span id="sizeValue">5</span>px</label>
      <input type="range" id="sizeSlider" min="1" max="50" value="5" />
    </div>

    <div class={styles.toolGroup}>
      <label>뷰</label>
      <div class={styles.tools}>
        <button id="zoomInBtn" class={styles.actionBtn} title="확대">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="11" cy="11" r="8" /><line x1="21" y1="21" x2="16.65" y2="16.65" /><line x1="11" y1="8" x2="11" y2="14" /><line x1="8" y1="11" x2="14" y2="11" />
          </svg>
        </button>
        <button id="zoomOutBtn" class={styles.actionBtn} title="축소">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="11" cy="11" r="8" /><line x1="21" y1="21" x2="16.65" y2="16.65" /><line x1="8" y1="11" x2="14" y2="11" />
          </svg>
        </button>
        <button id="fitViewBtn" class={styles.actionBtn} title="맞춤">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M8 3H5a2 2 0 00-2 2v3m18 0V5a2 2 0 00-2-2h-3m0 18h3a2 2 0 002-2v-3M3 16v3a2 2 0 002 2h3" />
          </svg>
        </button>
        <button id="resetViewBtn" class={styles.actionBtn} title="1:1">
          <span>1:1</span>
        </button>
        <span id="zoomLevel" class={styles.zoomLevel}>100%</span>
      </div>
    </div>

    <div class={styles.toolGroup}>
      <div class={styles.tools}>
        <button id="exportSvgBtn" class={styles.actionBtn} title="SVG 다운로드">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4" />
            <polyline points="7 10 12 15 17 10" />
            <line x1="12" y1="15" x2="12" y2="3" />
          </svg>
          <span>SVG</span>
        </button>
        <button id="clearBtn" class={styles.clearBtn}>전체 지우기</button>
      </div>
    </div>
  </div>

  <div class={styles.canvasContainer}>
    <canvas id="rust-canvas"></canvas>
  </div>
</div>

<script>
  import init, { Canvas } from '@/lib/wasm/rust-canvas/rust_canvas.js';

  interface Position {
    x: number;
    y: number;
  }

  const LOGICAL_WIDTH = 800;
  const LOGICAL_HEIGHT = 500;

  type Tool = 'pen' | 'eraser' | 'select' | 'line' | 'rect' | 'circle';
  let currentTool: Tool = 'pen';

  function isShapeTool(tool: Tool): boolean {
    return tool === 'line' || tool === 'rect' || tool === 'circle';
  }

  /** input/textarea/select 에서의 이벤트인지 확인 */
  function isInputFocused(e: KeyboardEvent): boolean {
    const tag = (e.target as HTMLElement)?.tagName;
    return tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT';
  }

  // getBoundingClientRect 캐시 (드래그 중 레이아웃 재계산 방지)
  let cachedRect: DOMRect | null = null;

  // Space 키 팬 모드
  let isSpaceDown = false;

  function cacheRect(canvasEl: HTMLCanvasElement): void {
    cachedRect = canvasEl.getBoundingClientRect();
  }

  /** 스크린 스페이스 논리 좌표 (0~800, 0~500) */
  function getPosition(e: MouseEvent | TouchEvent, canvasEl: HTMLCanvasElement): Position {
    const rect = cachedRect || canvasEl.getBoundingClientRect();
    const scaleX = LOGICAL_WIDTH / rect.width;
    const scaleY = LOGICAL_HEIGHT / rect.height;

    if ('touches' in e && e.touches.length > 0) {
      return {
        x: (e.touches[0].clientX - rect.left) * scaleX,
        y: (e.touches[0].clientY - rect.top) * scaleY,
      };
    }

    const mouseEvent = e as MouseEvent;
    return {
      x: (mouseEvent.clientX - rect.left) * scaleX,
      y: (mouseEvent.clientY - rect.top) * scaleY,
    };
  }

  /** 월드 스페이스 좌표 (스크린 좌표를 줌/팬 역변환) */
  function getWorldPosition(e: MouseEvent | TouchEvent, canvasEl: HTMLCanvasElement, canvas: Canvas): Position {
    const screen = getPosition(e, canvasEl);
    return {
      x: canvas.screen_to_world_x(screen.x),
      y: canvas.screen_to_world_y(screen.y),
    };
  }

  function setActiveState(element: Element, isActive: boolean): void {
    element.setAttribute('data-active', String(isActive));
  }

  function setupCanvasSize(canvasEl: HTMLCanvasElement): number {
    const dpr = window.devicePixelRatio || 1;

    canvasEl.width = LOGICAL_WIDTH * dpr;
    canvasEl.height = LOGICAL_HEIGHT * dpr;
    canvasEl.style.width = `${LOGICAL_WIDTH}px`;
    canvasEl.style.height = `${LOGICAL_HEIGHT}px`;

    return dpr;
  }

  function updateZoomDisplay(canvas: Canvas): void {
    const el = document.getElementById('zoomLevel');
    if (el) {
      el.textContent = `${Math.round(canvas.get_zoom() * 100)}%`;
    }
  }

  function setupDrawingEvents(canvasEl: HTMLCanvasElement, canvas: Canvas): void {
    // Mouse events
    canvasEl.addEventListener('mousedown', (e) => {
      cacheRect(canvasEl);

      // Space 팬 모드 또는 중간 버튼
      if (isSpaceDown || e.button === 1) {
        e.preventDefault();
        const pos = getPosition(e, canvasEl);
        canvas.start_pan(pos.x, pos.y);
        canvasEl.style.cursor = 'grabbing';
        return;
      }

      const world = getWorldPosition(e, canvasEl, canvas);
      const screen = getPosition(e, canvasEl);

      if (currentTool === 'select') {
        if (canvas.has_selection() && canvas.is_over_selected(world.x, world.y)) {
          canvas.start_move(world.x, world.y);
        } else {
          const hit = canvas.try_select_at(world.x, world.y, e.shiftKey);
          if (hit && canvas.is_over_selected(world.x, world.y)) {
            canvas.start_move(world.x, world.y);
          } else if (!hit) {
            // 러버밴드는 스크린 좌표
            canvas.start_rubber_band(screen.x, screen.y);
          }
        }
      } else if (isShapeTool(currentTool)) {
        canvas.start_shape(world.x, world.y);
      } else {
        canvas.start_drawing(world.x, world.y);
      }
    });

    canvasEl.addEventListener('mousemove', (e) => {
      // 팬 모드
      if (canvas.get_is_panning()) {
        const pos = getPosition(e, canvasEl);
        canvas.update_pan(pos.x, pos.y);
        updateZoomDisplay(canvas);
        return;
      }

      const screen = getPosition(e, canvasEl);
      const world = getWorldPosition(e, canvasEl, canvas);

      if (isSpaceDown) {
        canvasEl.style.cursor = 'grab';
        return;
      }

      if (currentTool === 'select') {
        if (canvas.get_is_rubber_band()) {
          canvas.update_rubber_band(screen.x, screen.y);
          canvasEl.style.cursor = 'crosshair';
        } else if (canvas.get_is_moving()) {
          canvas.move_selected(world.x, world.y);
        } else {
          if (canvas.has_selection() && canvas.is_over_selected(world.x, world.y)) {
            canvasEl.style.cursor = 'move';
          } else {
            canvasEl.style.cursor = 'default';
          }
        }
      } else if (isShapeTool(currentTool)) {
        if (canvas.get_is_drawing_shape()) {
          canvas.update_shape(world.x, world.y);
        }
      } else {
        // 커서 프리뷰는 스크린 좌표
        canvas.update_cursor(screen.x, screen.y);
        if (canvas.get_is_drawing()) {
          canvas.draw(world.x, world.y);
        }
      }
    });

    canvasEl.addEventListener('mouseup', (e) => {
      if (canvas.get_is_panning()) {
        canvas.stop_pan();
        canvasEl.style.cursor = isSpaceDown ? 'grab' : (currentTool === 'select' ? 'default' : 'crosshair');
        cachedRect = null;
        return;
      }

      if (currentTool === 'select') {
        if (canvas.get_is_rubber_band()) {
          canvas.finish_rubber_band(e.shiftKey);
        }
        canvas.stop_move();
      } else if (isShapeTool(currentTool)) {
        canvas.finish_shape();
      } else {
        canvas.stop_drawing();
      }
      cachedRect = null;
    });

    canvasEl.addEventListener('mouseleave', (e) => {
      if (canvas.get_is_panning()) {
        canvas.stop_pan();
      }
      if (currentTool === 'select') {
        if (canvas.get_is_rubber_band()) {
          canvas.finish_rubber_band(e.shiftKey);
        }
        canvas.stop_move();
      } else if (isShapeTool(currentTool)) {
        canvas.finish_shape();
      } else {
        canvas.stop_drawing();
      }
      canvas.hide_cursor();
      cachedRect = null;
    });

    // Wheel zoom (Ctrl/Meta + 휠만 줌, 그 외 스크롤 허용)
    canvasEl.addEventListener('wheel', (e) => {
      if (e.ctrlKey || e.metaKey) {
        e.preventDefault();
        const pos = getPosition(e, canvasEl);
        canvas.zoom_at(pos.x, pos.y, e.deltaY);
        updateZoomDisplay(canvas);
      }
    }, { passive: false });

    // Touch events
    canvasEl.addEventListener(
      'touchstart',
      (e) => {
        e.preventDefault();
        cacheRect(canvasEl);
        const world = getWorldPosition(e, canvasEl, canvas);
        const screen = getPosition(e, canvasEl);

        if (currentTool === 'select') {
          if (canvas.has_selection() && canvas.is_over_selected(world.x, world.y)) {
            canvas.start_move(world.x, world.y);
          } else {
            const hit = canvas.try_select_at(world.x, world.y, false);
            if (hit && canvas.is_over_selected(world.x, world.y)) {
              canvas.start_move(world.x, world.y);
            } else if (!hit) {
              canvas.start_rubber_band(screen.x, screen.y);
            }
          }
        } else if (isShapeTool(currentTool)) {
          canvas.start_shape(world.x, world.y);
        } else {
          canvas.start_drawing(world.x, world.y);
        }
      },
      { passive: false }
    );

    canvasEl.addEventListener(
      'touchmove',
      (e) => {
        e.preventDefault();
        const world = getWorldPosition(e, canvasEl, canvas);
        const screen = getPosition(e, canvasEl);

        if (currentTool === 'select') {
          if (canvas.get_is_rubber_band()) {
            canvas.update_rubber_band(screen.x, screen.y);
          } else if (canvas.get_is_moving()) {
            canvas.move_selected(world.x, world.y);
          }
        } else if (isShapeTool(currentTool)) {
          if (canvas.get_is_drawing_shape()) {
            canvas.update_shape(world.x, world.y);
          }
        } else {
          canvas.draw(world.x, world.y);
        }
      },
      { passive: false }
    );

    canvasEl.addEventListener('touchend', () => {
      if (currentTool === 'select') {
        if (canvas.get_is_rubber_band()) {
          canvas.finish_rubber_band(false);
        }
        canvas.stop_move();
      } else if (isShapeTool(currentTool)) {
        canvas.finish_shape();
      } else {
        canvas.stop_drawing();
      }
      cachedRect = null;
    });
  }

  function setupToolButtons(
    canvas: Canvas,
    canvasEl: HTMLCanvasElement
  ): void {
    const selectBtn = document.getElementById('selectBtn')!;
    const penBtn = document.getElementById('penBtn')!;
    const eraserBtn = document.getElementById('eraserBtn')!;
    const lineBtn = document.getElementById('lineBtn')!;
    const rectBtn = document.getElementById('rectBtn')!;
    const circleBtn = document.getElementById('circleBtn')!;

    const allToolBtns = [selectBtn, penBtn, eraserBtn, lineBtn, rectBtn, circleBtn];

    function activateTool(activeBtn: Element, tool: Tool) {
      allToolBtns.forEach((btn) => setActiveState(btn, btn === activeBtn));
      currentTool = tool;
      canvas.set_tool_mode(tool);

      if (tool === 'select') {
        canvasEl.style.cursor = 'default';
      } else if (isShapeTool(tool)) {
        canvasEl.style.cursor = 'crosshair';
        canvas.deselect_all();
      } else {
        canvasEl.style.cursor = 'none';
        canvas.deselect_all();
      }
    }

    selectBtn.addEventListener('click', () => activateTool(selectBtn, 'select'));
    penBtn.addEventListener('click', () => activateTool(penBtn, 'pen'));
    eraserBtn.addEventListener('click', () => activateTool(eraserBtn, 'eraser'));
    lineBtn.addEventListener('click', () => activateTool(lineBtn, 'line'));
    rectBtn.addEventListener('click', () => activateTool(rectBtn, 'rect'));
    circleBtn.addEventListener('click', () => activateTool(circleBtn, 'circle'));
  }

  function setupActionButtons(canvas: Canvas): void {
    const undoBtn = document.getElementById('undoBtn');
    const redoBtn = document.getElementById('redoBtn');
    const copyBtn = document.getElementById('copyBtn');
    const pasteBtn = document.getElementById('pasteBtn');
    const deleteBtn = document.getElementById('deleteBtn');
    const selectAllBtn = document.getElementById('selectAllBtn');

    undoBtn?.addEventListener('click', () => canvas.undo());
    redoBtn?.addEventListener('click', () => canvas.redo());

    copyBtn?.addEventListener('click', () => {
      if (canvas.has_selection()) {
        canvas.copy_selected();
      }
    });

    pasteBtn?.addEventListener('click', () => {
      canvas.paste();
    });

    deleteBtn?.addEventListener('click', () => {
      if (canvas.has_selection()) {
        canvas.delete_selected();
      }
    });

    selectAllBtn?.addEventListener('click', () => {
      canvas.select_all();
    });
  }

  function setupZoomButtons(canvas: Canvas, canvasEl: HTMLCanvasElement): void {
    const zoomInBtn = document.getElementById('zoomInBtn');
    const zoomOutBtn = document.getElementById('zoomOutBtn');
    const fitViewBtn = document.getElementById('fitViewBtn');
    const resetViewBtn = document.getElementById('resetViewBtn');

    zoomInBtn?.addEventListener('click', () => {
      canvas.set_zoom(canvas.get_zoom() * 1.25);
      updateZoomDisplay(canvas);
    });

    zoomOutBtn?.addEventListener('click', () => {
      canvas.set_zoom(canvas.get_zoom() / 1.25);
      updateZoomDisplay(canvas);
    });

    fitViewBtn?.addEventListener('click', () => {
      canvas.fit_to_view();
      updateZoomDisplay(canvas);
    });

    resetViewBtn?.addEventListener('click', () => {
      canvas.reset_view();
      updateZoomDisplay(canvas);
    });
  }

  function setupColorControls(
    canvas: Canvas,
    colorPicker: HTMLInputElement,
    colorBtns: NodeListOf<Element>,
    canvasEl: HTMLCanvasElement
  ): void {
    const penBtn = document.getElementById('penBtn')!;
    const allToolBtnIds = ['selectBtn', 'penBtn', 'eraserBtn', 'lineBtn', 'rectBtn', 'circleBtn'];

    function switchToPen() {
      canvas.set_color(colorPicker.value);
      canvas.set_tool_mode('pen');
      currentTool = 'pen';
      allToolBtnIds.forEach((id) => {
        const el = document.getElementById(id);
        if (el) setActiveState(el, el === penBtn);
      });
      canvasEl.style.cursor = 'none';
      canvas.deselect_all();
    }

    colorPicker.addEventListener('input', (e) => {
      const target = e.target as HTMLInputElement;
      canvas.set_color(target.value);
      switchToPen();
      colorBtns.forEach((btn) => setActiveState(btn, false));
    });

    colorBtns.forEach((btn) => {
      btn.addEventListener('click', () => {
        const color = (btn as HTMLElement).dataset.color;
        if (!color) return;

        canvas.set_color(color);
        colorPicker.value = color;
        switchToPen();
        colorBtns.forEach((b) => setActiveState(b, false));
        setActiveState(btn, true);
      });
    });
  }

  function setupSizeSlider(canvas: Canvas, sizeSlider: HTMLInputElement, sizeValue: Element): void {
    sizeSlider.addEventListener('input', (e) => {
      const target = e.target as HTMLInputElement;
      const size = parseInt(target.value, 10);
      canvas.set_line_width(size);
      sizeValue.textContent = String(size);
    });
  }

  function setupKeyboardShortcuts(canvas: Canvas, canvasEl: HTMLCanvasElement): void {
    document.addEventListener('keydown', (e) => {
      // input/textarea/select 에서는 단축키 무시
      if (isInputFocused(e)) return;

      // Space 키 팬 모드
      if (e.code === 'Space' && !e.repeat) {
        e.preventDefault();
        isSpaceDown = true;
        canvasEl.style.cursor = 'grab';
        return;
      }

      if (e.key === 'Delete' || e.key === 'Backspace') {
        if (canvas.has_selection()) {
          e.preventDefault();
          canvas.delete_selected();
        }
      }

      if (e.ctrlKey || e.metaKey) {
        if (e.key === 'z' && !e.shiftKey) {
          e.preventDefault();
          canvas.undo();
        }
        if (e.key === 'z' && e.shiftKey) {
          e.preventDefault();
          canvas.redo();
        }
        if (e.key === 'y') {
          e.preventDefault();
          canvas.redo();
        }
        if (e.key === 'c') {
          if (canvas.has_selection()) {
            e.preventDefault();
            canvas.copy_selected();
          }
        }
        if (e.key === 'v') {
          e.preventDefault();
          canvas.paste();
        }
        if (e.key === 'a') {
          if (currentTool === 'select') {
            e.preventDefault();
            canvas.select_all();
          }
        }
      }

      if (e.key === 'Escape') {
        canvas.deselect_all();
      }

      // 도구 단축키 (Ctrl/Meta 없을 때만)
      if (!e.ctrlKey && !e.metaKey && !e.altKey) {
        const toolShortcuts: Record<string, string> = {
          v: 'selectBtn', p: 'penBtn', e: 'eraserBtn',
          l: 'lineBtn', r: 'rectBtn', o: 'circleBtn',
        };
        const btnId = toolShortcuts[e.key.toLowerCase()];
        if (btnId) {
          const btn = document.getElementById(btnId);
          if (btn) btn.click();
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      if (e.code === 'Space') {
        isSpaceDown = false;
        if (canvas.get_is_panning()) {
          canvas.stop_pan();
        }
        if (currentTool === 'select') {
          canvasEl.style.cursor = 'default';
        } else {
          canvasEl.style.cursor = 'none';
        }
      }
    });
  }

  async function initRustCanvas(): Promise<void> {
    await init();

    const canvasEl = document.getElementById('rust-canvas') as HTMLCanvasElement | null;
    if (!canvasEl) {
      console.error('Canvas element not found');
      return;
    }

    const dpr = setupCanvasSize(canvasEl);
    const canvas = new Canvas('rust-canvas', dpr);
    canvas.start_render_loop();
    canvas.clear();

    const colorPicker = document.getElementById('colorPicker') as HTMLInputElement | null;
    const colorBtns = document.querySelectorAll('[data-color]');
    const sizeSlider = document.getElementById('sizeSlider') as HTMLInputElement | null;
    const sizeValue = document.getElementById('sizeValue');
    const clearBtn = document.getElementById('clearBtn');

    if (!colorPicker || !sizeSlider || !sizeValue || !clearBtn) {
      console.error('Required elements not found');
      return;
    }

    canvasEl.style.cursor = 'none';

    setupDrawingEvents(canvasEl, canvas);
    setupToolButtons(canvas, canvasEl);
    setupActionButtons(canvas);
    setupZoomButtons(canvas, canvasEl);
    setupColorControls(canvas, colorPicker, colorBtns, canvasEl);
    setupSizeSlider(canvas, sizeSlider, sizeValue);
    setupKeyboardShortcuts(canvas, canvasEl);

    clearBtn.addEventListener('click', () => canvas.clear());

    const exportSvgBtn = document.getElementById('exportSvgBtn');
    exportSvgBtn?.addEventListener('click', () => {
      const svgStr = canvas.export_svg();
      const blob = new Blob([svgStr], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'canvas.svg';
      a.click();
      URL.revokeObjectURL(url);
    });

    updateZoomDisplay(canvas);
  }

  initRustCanvas();
</script>
